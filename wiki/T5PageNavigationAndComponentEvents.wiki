=Apache Tapestry 5: Навигация по страницам и события компонентов=

Приложение Tapestry, по своей сути, это набор взаимосвязанных страниц. Страница, это в некотором роде, приложение в приложении.

Каждый HTTP запрос попадает в конкретную (одну) страницу. Существует два типа запросов:

 * _событие компонента (component event)_. Запрос предназначается для конкретного компонента на конкретной странице для вызова события в этом компоненте;

 * _отрисовка (render)_. Запрос предназначается для отрисовки страницы, в ответ клиент получает поток с HTML разметкой страницы.

Разделение между событиями компонентов и отрисовкой появились начиная с Tapestry 5. Этот подход частично основан на идеях заложенных в спецификации портлетов. Выделение двух типов запросов снимает ряд проблем традиционных веб-приложений связанных с фунцией перехода на предыдущую страницу, или обновлении страниц в браузере.

==Запрос события компонента (Component Event Requests)==

(Основная статья [http://tapestry.apache.org/component-events.html Component Events])

Запрос события компонента может иметь форму гиперссылки (компоненты !ActionLink, !EventLink) или отправки формы (Form submission).

Значение возвращаемое обработчиком события управляет ответом, который посылается браузеру.

URL события компонента определяется именем страницы, вложенным идентификатором компонента и именем события, которое вызывается у компонента (событие по умолчанию - "action"). Кроме этого событие компонента может содержать дополнительную контекстную информацию, предоставляемую обработчику события.

Этот URLs частично связан с внутренней структурой приложения. В процессе развития и поддержки приложения идентификатор компонента может изменится. Поэтому такие URL не должны помещаться в закладки. Радует то, что у пользователей редко появляется такая возможность (см. ниже).

===Null ответ===

Если обработчик события возвращает null или вообще не возвращает значения (void), то текущая страница (содержащая компонент) будет отрисована в ответе.

Ссылка отрисовки страницы (page render link) для текущей страницы создается и посылается клиенту в виде клиентского перенаправления. Браузер клиента автоматически посылает новый запрос для генерации страницы.

Пользователь увидит заново сгенерированную страницу в браузере. URL в адресной строке браузера отобразит URL отрисовки страницы. URL запроса отрисовки короче и менее привязан к структуре приложения (например он не содержит идентификатора компонента и типа события). URL запроса отрисовки может быть помещен в закладки пользователя. URL запроса события компонента временный, и имеет смысл только в сеансе работы приложения и не предназначен для использования в других сеансах.

===Строковый ответ===

Когда возвращается строка, то ожидается логическое имя страницы (в отличии от полного имени класса страницы). Имя страницы регистронезависимо.

URL запроса отрисовки страницы отправляется клиенту как перенаправление.

===Ответ типа Class===

Когда возвращается класс, то ожидается класс страницы. Возвращаемое значение типа Class безопаснее для рефакторинга чем возврат имени страницы.

Как и в других типах ответов будет собран URL отрисовки страницы и отправлен как клиентское перенаправление.

===Ответ в виде страницы===

Так же можно возвращать экземпляр страницы вместо имени или класса страницы.

Страница может быть вставлена в другую страницу/компонент с помощью аннотации !InjectPage.

Часто нужно настроить состояние страницы перед тем как ее вернуть.

Также можно вернуть компонент страницы, но это приведет к предупреждению времени исполнения.

===Ответ типа Link===

Обработчик события может прямо вернуть экземпляр Link. Link преобразуется в URL и клиенту будет отправлено перенаправление на этот URL.

В объекте ComponentResources, вставленном в класс страницы или компонента, есть методы для создания ссылки запроса события компонента, а в сервисе PageRenderLinkSource есть методы для создания ссылок отрисовки страниц (последнее применительно к версии 5.1).

===Потоковый ответ===

Обработчик события так же может вернуть объект !StreamResponse, который инкапсулирует поток, который будет отправлен прямо в браузер клиента. Потоковый ответ используется в таких ситуациях как генерация изображения или PDF и отправки его клиенту.

===Ответ типа URL===

URL обрабатывается как перенаправление клиента на внешний URL.

===Ответ типа Object===

Любые другие типы объектов, возвращенные обработчиком события являются ошибкой.

Схематично процесс обработки запроса внутри страницы выглядит следующим образом:

http://orion-cpu.googlecode.com/svn/wiki/T5PageRendering.jpeg

==Запросы отрисовки страниц==

Запросы отрисовки структурно проще чем запросы событий компонента. В простейшем случае токой URL это просто логическое имя страницы.

У страницы может быть контекст активации. Контекст активации содержит постоянную (persistent) информацию о состоянии страницы. В практическом смысле это обычно идентификатор объекта, который хранится в базе данных.

Когда у страницы есть контекст активации, то значения контекста добавляются к пути URL.

Не у всех страниц есть контекст активации.

Контекст активации может быть явно задан когда создается ссылка на нее (у компонента !PageLink есть параметр context как раз для этого). Если нет явно заданного контекста активации, то страница запросит его сама у себя.

Этот запрос выглядит как вызов события с именем "passivate" (ниже будет показано как оно соответствует "activate"). Возвращаемое значение метода-обработчика используется как контекст активации. Например:
{{{
public class ProductDetail
{
private Product product;
. . .
long onPassivate() { return product.getId(); }
}
}}}
Контекст активации может содержать вектор значений, в этом случае возвращаемое значение должно быть массивом или List.

Примечание: если вы используете библиотеку интеграции tapestry-hibernate или tapestry-jpa и в возвращаемом значении обработчика пасивации нужна сущность Hibernate/JPA, то можно указывать саму сущность, а не ее идентификатор. Tapestry автоматически извлечет идентификатор сущности в URL, и преобразует ее обратно для обработчика события активации.

===Активация страницы===

Когда приходит запрос отрисовки страница будет активирована до того как будет отрисована.

Активация преследует две цели:

 * Позволяет странице восстановить внутреннее состояние по данным закодированным в URL (контекст активации рассмотрен выше).

 * Она предоставляет возможность для грубой проверки возможности доступа к странице.

Последнее - проверка доступа, как правило, связана с идентификацией пользователя и доступа. Если у вас есть страницы, которые могут быть доступны только определенным пользователям, то вы можете использовать обработчик события активации страницы для проверки прав доступа.

Обработчик события активации страницы обычно зеркально отражает ее обработчик пасивации, т.е. вектор аргументов onActivate это такой же вектор, который возвращает onPassivate:

{{{
. . .
void onActivate(long productId)
{
product = productDAO.getById(productId);
}
. . .
}}}

Если страница должна обрабатывать контексты активации разной длины, то она должна иметь несколько соответствующих методов onActivate. При этом методы должны обязательно различаться *количеством* аргументов: 

{{{
. . .

void onActivate(String productType)
{
products = productDAO.getByType(productType);
}

void onActivate(String productType, String productColor)
{
products = productDAO.getByTypeAndColor(productType, productColor);
}
. . .
}}}

Другой вариант - это метод onActivate с одним аргументом типа !EventContext:

{{{
. . .

void onActivate(EventContext context)
{
String path;
for(int i=0;i<context.getCount();i++)
  path+=context.get(String.class, i)+"/";
products = productDAO.getByPath(path);
}
. . .
}}}


Еще один важный момент: Когда страница отрисовывается, она может включать много URLов запросов событий компонентов (ссылок и форм). Обработка всех этих событий начнется с активации страницы, а после этого будет вызван сам обработчик. Такая форма обработки позволяет восстанавливать контекстное состояние страницы путем передачи того же самого контекста в URL.

В некоторых случаях можно получить тот же эффект используя персистентные переменные страницы, но это требует активной сессии, и результат не может быть помещен в закладки.

Обработчик активации может возвращать значение, которое потоково идентичны возвращаемому значению ...

==Модели HTTP запросов==

Аctionlink, его контекст и контекст страницы могут сочетаться разными способами.

Рассмотрим обычную связку master/detail на примере страницы каталога товаров. В этом примере страница !ProductListing это список товаров, а  !ProductDetails должна показывать детали конкретного товара.

===Событие компонента / Хранимые данные===

В этой модели страница !ProductListing использует аргументы события и  persistent поля страницы !ProductDetails.

====!ProductListing.html:====

{{{
<t:loop source="products" value="product">

<a t:type="actionlink" t:id="select" context="product.id">${product.name}</a>

</t:loop>
}}}

====!ProductListing.java:====
{{{
@InjectPage

private ProductDetails details;

Object onActionFromSelect(long productId)

{

details.setProductId(productId);

return details;

}
}}}
====!ProductDetails.java:====
{{{
@Inject

private ProductDAO dao;

private Product product;

@Persist

private long productId;

public void setProductId(long productId) { this.productId = productId; }

void onActivate()

{

product = dao.getById(productId);

}
}}}
Этот минимальный пример хорошо подходит в качестве образца.

Когда пользователь кликает ссылку, то URL события компонента будет представлять собой что-то вроде `"http://.../productlisting.select/99"`, а the URL запроса страницы что-то вроде `"http://.../productdetails"`. Обратите внимание что идентификатор товара ("99") не передается в URL запроса страницы.

Подход имеет некоторые незначительные недостатки:

 * Требуется сессия для сохранения `_productId` между запросами.

 * Если страница !ProductDetails будет запрошена до того как верный идентификатор товара был установлен, то произойдет ошибка.

 * По URL невозможно идентифицировать товар; если пользователь сохранит в закладке этот URL и откроет его позднее, то это приведет к предыдущей ситуации.

===Событие компонента / Без хранимых данных===

Можно улучшить предыдущий пример изменив страницу !ProductListing так, что-бы использовать контексты пасивации и активации, избежать использования сессии и делая ссылки пригодными для сохранения в закладках.

====!ProductDetails.java:====
{{{
@Inject

private ProductDAO dao;

private Product product;

private long productId;

public void setProductId(long productId) { productId = productId; }

void onActivate(long productId)

{

this.productId = productId;

product = dao.getById(productId);

}

long onPassivate() { return productId; }
}}}

При таком изменении URL запроса обязательно содержит идентификатор товара. Например: `"http://.../productdetails/99"`.

Преимущество этого варианта в том, что связь между страницами происходит через типизированный Java-кода, внутри onActionFromSelect метода в !ProductListing. Недостаток в том, что для получения страницы требуется  два обращения к серверу

===Только запрос отрисовки===

Наиболее общая версия связи master/detail.

====!ProductListing.html:====
{{{
<t:loop source="products" value="product">

<a t:type="pagelink" page="productdetails" context="product.id">${product.name}</a>

</t:loop>
}}}
====!ProductListing.java:====
{{{
No code is needed to support the link.
}}}
====!ProductDetails.java:====
{{{
@Inject

private ProductDAO dao;

private Product product;

private long productId;

void onActivate(long productId)

{

this.productId = productId;

product = dao.getById(productId);

}

long onPassivate() { return productId; }
}}}
Метод setProductId() больше не требуется.

==Ограничения==

При разрастании веб-приложения скорее всего возникнет ситуация, когда не имеет смысла или вообще невозможно сохранение некоторых данных между запросами внутри URL запроса. Например если со страницы !ProductDetails пользователь может перейти на связанные страницы, а потом вернуться на !ProductDetails, то может быть важным работать на всех этих страницах с одним и тем же товаром и хранить его идентификатор в странице !ProductDetails.

В некоторых случаях хранимые значения более приемлемы. В Tapestry5 реализовано несколько стратегий хранения данных. Есть даже стратегия, которая сохраняет данные в параметры URL [http://tapestry.apache.org/persistent-page-data.html См. Persistent Page Data].

Статья написана на базе перевода: `http://tapestry.apache.org/page-navigation.html`