=Apache Tapestry 5: Навигация по страницам и события компонентов=

Приложение Tapestry, по своей сути, это набор взаимосвязанных страниц. Страница, это в некотором роде, приложение в приложении.

Каждый HTTP запрос попадает в конкретную (одну) страницу. Существует два типа запросов:

 * _событие компонента (component event)_. Запрос предназначается для конкретного компонента на конкретной странице для вызова события в этом компоненте;

 * _отрисовка (render)_. Запрос предназначается для отрисовки страницы, в ответ клиент получает поток с HTML разметкой страницы.

Разделение между событиями компонентов и отрисовкой появились начиная с Tapestry 5. Этот подход частично основан на идеях заложенных в спецификации портлетов. Выделение двух типов запросов снимает ряд проблем традиционных веб-приложений связанных с фунцией перехода на предыдущую страницу, или обновлении страниц в браузере.

==Запрос события компонента (Component Event Requests)==

(Основная статья [http://tapestry.apache.org/component-events.html Component Events])

Запрос события компонента может иметь форму гиперссылки (компоненты !ActionLink, !EventLink) или отправки формы (Form submission).

Значение возвращаемое обработчиком события управляет ответом, который посылается браузеру.

URL события компонента определяется именем страницы, вложенным идентификатором компонента и именем события, которое вызывается у компонента (событие по умолчанию - "action"). Кроме этого событие компонента может содержать дополнительную контекстную информацию, предоставляемую обработчику события.

Этот URLs частично связан с внутренней структурой приложения. В процессе развития и поддержки приложения идентификатор компонента может изменится. Поэтому такие URL не должны помещаться в закладки. Радует то, что у пользователей редко появляется такая возможность (см. ниже).

===Null ответ===

Если обработчик события возвращает null или вообще не возвращает значения (void), то текущая страница (содержащая компонент) будет отрисована в ответе.

Ссылка отрисовки страницы (page render link) для текущей страницы создается и посылается клиенту в виде клиентского перенаправления. Браузер клиента автоматически посылает новый запрос для генерации страницы.

Пользователь увидит заново сгенерированную страницу в браузере. URL в адресной строке браузера отобразит URL отрисовки страницы. URL запроса отрисовки короче и менее привязан к структуре приложения (например он не содержит идентификатора компонента и типа события). URL запроса отрисовки может быть помещен в закладки пользователя. URL запроса события компонента временный, и имеет смысл только в сеансе работы приложения и не предназначен для использования в других сеансах.

===Строковый ответ===

Когда возвращается строка, то ожидается логическое имя страницы (в отличии от полного имени класса страницы). Имя страницы регистронезависимо.

URL запроса отрисовки страницы отправляется клиенту как перенаправление.

===Ответ типа Class===

Когда возвращается класс, то ожидается класс страницы. Возвращаемое значение типа Class безопаснее для рефакторинга чем возврат имени страницы.

Как и в других типах ответов будет собран URL отрисовки страницы и отправлен как клиентское перенаправление.

===Ответ в виде страницы===

Так же можно возвращать экземпляр страницы вместо имени или класса страницы.

Страница может быть вставлена в другую страницу/компонент с помощью аннотации !InjectPage.

Часто нужно настроить состояние страницы перед тем как ее вернуть.

Также можно вернуть компонент страницы, но это приведет к предупреждению времени исполнения.

===Ответ типа Link===

Обработчик события может прямо вернуть экземпляр Link. Link преобразуется в URL и клиенту будет отправлено перенаправление на этот URL.

В объекте ComponentResources, вставленном в класс страницы или компонента, есть методы для создания ссылки запроса события компонента, а в сервисе PageRenderLinkSource есть методы для создания ссылок отрисовки страниц (последнее применительно к версии 5.1 - прим. переводчика).

===Потоковый ответ===

Обработчик события так же может вернуть объект !StreamResponse, который инкапсулирует поток, который будет отправлен прямо в браузер клиента. Потоковый ответ используется в таких ситуациях как генерация изображения или PDF и отправки его клиенту.

===Ответ типа URL===

URL обрабатывается как перенаправление клиента на внешний URL.

===Ответ типа Object===

Любые другие типы объектов, возвращенные обработчиком события являются ошибкой.

==Запросы отрисовки страниц==

Запросы отрисовки структурно проще чем запросы событий компонента. В простейшем случае токой URL это просто логическое имя страницы.

У страницы может быть контекст активации. Контекст активации содержит постоянную (persistent) информацию о состоянии страницы. В практическом смысле это обычно идентификатор объекта, который хранится в базе данных.

Когда у страницы есть контекст активации, то значения контекста добавляются к пути URL.

Не у всех страниц есть контекст активации.

Контекст активации может быть явно задан когда создается ссылка на нее (у компонента !PageLink есть параметр context как раз для этого). Если нет явно заданного контекста активации, то страница запросит его сама у себя.

Этот запрос выглядит как вызов события с именем "passivate" (ниже будет показано как оно соответствует "activate"). Возвращаемое значение метода-обработчика используется как контекст активации. Например:
{{{
public class ProductDetail
{
private Product product;
. . .
long onPassivate() { return product.getId(); }
}
}}}
Контекст активации может содержать вектор значений, в этом случае возвращаемое значение должно быть массивом или List.

Примечание: если вы используете библиотеку интеграции tapestry-hibernate или tapestry-jpa и в возвращаемом значении обработчика пасивации нужна сущность Hibernate/JPA, то можно указывать саму сущность, а не ее идентификатор. Tapestry автоматически извлечет идентификатор сущности в URL, и преобразует ее обратно для обработчика события активации.

===Активация страницы===

Когда приходит запрос отрисовки страница будет активирована до того как будет отрисована.

Активация преследует две цели:

 * Позволяет странице восстановить внутреннее состояние по данным закодированным в URL (контекст активации рассмотрен выше).

 * Она предоставляет возможность для грубой проверки возможности доступа к странице.

Последнее - проверка доступа, как правило, связана с идентификацией пользователя и доступа. Если у вас есть страницы, которые могут быть доступны только определенным пользователям, то вы можете использовать обработчик события активации страницы для проверки прав доступа.

Обработчик события активации страницы обычно зеркально отражает ее обработчик пасивации, т.е. вектор аргументов onActivate это такой же вектор, который возвращает onPassivate:

{{{
. . .
void onActivate(long productId)
{
product = productDAO.getById(productId);
}
. . .
}}}

Если страница должна обрабатывать контексты активации разной длины, то она должна иметь несколько соответствующих методов onActivate. При этом методы должны обязательно различаться *количеством* аргументов: 

{{{
. . .

void onActivate(String productType)
{
products = productDAO.getByType(productType);
}

void onActivate(String productType, String productColor)
{
products = productDAO.getByTypeAndColor(productType, productColor);
}
. . .
}}}

Другой вариант - это метод onActivate с одним аргументом типа !EventContext:

{{{
. . .

void onActivate(EventContext context)
{
String path;
for(int i=0;i<context.getCount();i++)
  path+=context.get(String.class, i)+"/";
products = productDAO.getByPath(path);
}
. . .
}}}


Еще один важный момент: Когда страница отрисовывается, она может включать много URLов запросов событий компонентов (ссылок и форм). Обработка всех этих событий начнется с активации страницы, а после этого будет вызван сам обработчик. Такая форма обработки позволяет восстанавливать контекстное состояние страницы путем передачи того же самого контекста в URL.

В некоторых случаях можно получить тот же эффект используя персистентные переменные страницы, но это требует активной сессии, и результат не может быть помещен в закладки.

Обработчик активации может возвращать значение, которое потоково идентичны возвращаемому значению ...

==Модели HTTP запросов==

Аctionlink, его контекст и контекст страницы могут сочетаться разными способами.

Рассмотрим обычную связку master/detail на примере страницы каталога товаров. В этом примере страница ProductListing это список товаров, а  ProductDetails должна показывать детали конкретного товара.

===Событие компонента / Persistent Data===

В этой модели страница ProductListing использует аргументы события и  persistent поля страницы ProductDetails.

ProductListing.html:
{{{
<t:loop source="products" value="product">

<a t:type="actionlink" t:id="select" context="product.id">${product.name}</a>

</t:loop>
}}}

ProductListing.java:
{{{
@InjectPage

private ProductDetails details;

Object onActionFromSelect(long productId)

{

details.setProductId(productId);

return details;

}
}}}
ProductDetails.java:
{{{
@Inject

private ProductDAO dao;

private Product product;

@Persist

private long productId;

public void setProductId(long productId) { this.productId = productId; }

void onActivate()

{

product = dao.getById(productId);

}
}}}
Этот минимальный пример хорошо подходит в качестве образца.

Когда пользователь кликает ссылку, то URL события компонента будет представлять собой что-то вроде "http://.../productlisting.select/99", а the URL запроса страницы что-то вроде "http://.../productdetails". Обратите внимание что идентификатор товара ("99") не передается в URL запроса страницы.

Подход имеет некоторые незначительные недостатки:

 * Требуется сессия для сохранения _productId между запросами.

 * Если страница ProductDetails будет запрошена до того как верный идентификатор товара был установлен, то произойдет ошибка.

 * По URL невозможно идентифицировать товар; если пользователь сохранит в закладке этот URL и откроет его позднее, то это приведет к предыдущей ситуации.

===Component Event Requests / No Persistent Data===

We can improve the previous example without changing the ProductListing page, using a passivation and activation context to avoid the session and make the links more bookmarkable.

ProductDetails.java:
{{{
@Inject

private ProductDAO dao;

private Product product;

private long productId;

public void setProductId(long productId) { productId = productId; }

void onActivate(long productId)

{

this.productId = productId;

product = dao.getById(productId);

}

long onPassivate() { return productId; }
}}}
This change ensures that the render request URL will include the product id, i.e., "http://.../productdetails/99".

It has the advantage that the connection from page to page occurs in typesafe Java code, inside the onActionFromSelect method of ProductListing. It has the disadvantage that clicking a link requires two round trips to the server.

===Render Requests Only===

This is the most common version of this master/detail relationship.

ProductListing.html:
{{{
<t:loop source="products" value="product">

<a t:type="pagelink" page="productdetails" context="product.id">${product.name}</a>

</t:loop>
}}}
ProductListing.java:
{{{
No code is needed to support the link.
}}}
ProductDetails.java:
{{{
@Inject

private ProductDAO dao;

private Product product;

private long productId;

void onActivate(long productId)

{

this.productId = productId;

product = dao.getById(productId);

}

long onPassivate() { return productId; }
}}}
The setProductId() method is no longer needed.

==Limitations==

As your application's workflow expands, you may find that there is not a reasonable way to avoid storing some data persistently between requests, outside of the page activation context. For example, if from the ProductDetails page, the user is allowed to navigate to related pages and then back to ProductDetails, it starts to become necessary to keep passing that product id around from page to page to page.

At some point, persistent values make more sense. In the near future, there will be a client-side persistence strategy that will encode persistent data, such as the product id field, into query parameters (and hidden form fields) automatically.

Ссылка на оригинал: http://tapestry.apache.org/page-navigation.html